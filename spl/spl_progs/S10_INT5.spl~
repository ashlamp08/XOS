//--------------------------------------------------------
//	INTERRUPT ROUTINE 5
//	HAS FORK SYSTEM CALL
//--------------------------------------------------------


alias physicalSP S0;
physicalSP = ([PTBR + 2*(SP/512)]*512) + (SP % 512);

// Getting system call number from the stack and putting it in a register

alias sysCallNo S1;
sysCallNo = [physicalSP - 1];

if (sysCallNo == 8) then		//Implementation of Fork system call
	alias i S2;

//	print("in fork");

	i = 0;

	while(i<32) do			//See if new process can be created
		if([READY_LIST + i*32 + 1] == 0) then
			break;
		endif;
		i = i + 1;
	endwhile;	

	if(i==32) then			//New process cant be created
		[physicalSP - 2] = -1;
		ireturn;
	endif;

	alias childPID S3;		//new PID of child process
	childPID = i;

	[READY_LIST + childPID*32] = childPID;	//setting PID field of the PCB of child process

	i = 25;

	while(i<64) do			// 1 page required for stack
		if([MEM_LIST + i] == 0) then
			break;
		endif;
		i = i + 1;
	endwhile;

	if(i==64) then			//page not available for stack
		[physicalSP - 2] = -1;
		ireturn;
	endif;

	[MEM_LIST + i] = 1;		//page allocated to stack

	alias page S5;
	page = i;

	i = 0;

	while(i<512) do			//copying stack word by word
		[page*512 + i] = [[PTBR + 6]*512 + i];
		i = i + 1;
	endwhile;

	alias childPTBR S4;		//calculating childPTBR
	childPTBR = PAGE_TABLE + childPID*8;

	[childPTBR + 0] = [PTBR + 0];	//updating the pagetable values of child
	[childPTBR + 1] = [PTBR + 1];
	[childPTBR + 2] = [PTBR + 2];
	[childPTBR + 3] = [PTBR + 3];
	[childPTBR + 4] = [PTBR + 4];
	[childPTBR + 5] = [PTBR + 5];
	[childPTBR + 6] = page;
	[childPTBR + 7] = "01";

	//update memlist and disklist

	if([PTBR + 1]=="01" || [PTBR + 1]=="11") then	
		i = [MEM_LIST + [PTBR + 0]];
		i = i + 1;
	else
		i = [MEM_LIST + [PTBR + 0]];
		if(i>=448) then
			[DISK_LIST + i] = [DISK_LIST + i] + 1;
		endif;  
	endif;
	if([PTBR + 3]=="01" || [PTBR + 3]=="11") then
		i = [MEM_LIST + [PTBR + 2]];
		i = i + 1;
	else
		i = [MEM_LIST + [PTBR + 2]];
		if(i>=448) then
			[DISK_LIST + i] = [DISK_LIST + i] + 1;
		endif;  
	endif;
	if([PTBR + 5]=="01" || [PTBR + 5]=="11") then
		i = [MEM_LIST + [PTBR + 4]]; 
		i = i + 1;
	else
		i = [MEM_LIST + [PTBR + 4]];
		if(i>=448) then
			[DISK_LIST + i] = [DISK_LIST + i] + 1;
		endif;  
	endif;
	
	alias PID S6;
	PID = (PTBR - PAGE_TABLE)/8;

	//update the PCB of child

	i = READY_LIST + childPID*32;	
	
	[i] = childPID;
	[i + 6] = 4;	
	[i + 5] = PAGE_TABLE + childPID*8;
	[i + 4] = [physicalSP];
	[i + 3] = SP - 1;
	[i + 2] = BP;
	[i + 1] = 1;
	[i + 7] = R0;
	[i + 8] = R1;
	[i + 9] = R2;
	[i + 10] = R3;
	[i + 11] = R4;
	[i + 12] = R5;
	[i + 13] = R6;
	[i + 14] = R7;
	[i + 31] = PID;

	i = 0;		//updating the PPOFT and SWOFT  

	while(i<16) do
		S7 = READY_LIST + childPID*32 + 15 + i;
	
		[S7] = [READY_LIST + PID*32 + 15 + i];
		[S7 + 1] = [READY_LIST + PID*32 + 15 + i+1];	
	
		if([S7]!=-1) then
			[FILE_TABLE + [S7] + 1] = [FILE_TABLE + [S7] + 1] + 1;
		endif;
		i = i + 2;
	endwhile; 

	[physicalSP - 2] = childPID;	//parent process return value

	alias physicalSP_child S7;
	physicalSP_child = ([PAGE_TABLE + childPID*8 + 2*((SP-1)/512)]*512) + ((SP-1) % 512);

	[physicalSP_child - 1] = -2;	//child process return value		

	ireturn;
endif;


[physicalSP - 2] = -1;
ireturn;

	

	
	

			
			
		








